<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Solvepnp 5 Methods In Opencv3</title><meta name="twitter:card" content="summary" /><meta name="twitter:site" content="@nimohunter" /><meta name="twitter:title" content="Solvepnp 5 Methods In Opencv3" /><meta name="twitter:description" content="Before BeginSolvePnP , Finds an object pose from 3D-2D point correspondences., which is the method that rebuild 3D position from 2D picture."><meta name="description" content="Before BeginSolvePnP , Finds an object pose from 3D-2D point correspondences., which is the method that rebuild 3D position from 2D picture."><link rel="icon" href="/assets/favicon.png"><link rel="apple-touch-icon" href="/assets/touch-icon.png"><link href="https://fonts.googleapis.com/css?family=Karla" rel="stylesheet"><link rel="stylesheet" href="/assets/core.css"><link rel="canonical" href="/notes/SolvePnP-5-Methods-in-Opencv3.html"><link rel="alternate" type="application/atom+xml" title="Nimo" href="/feed.xml" /></head><body><aside class="logo"> <a href="/"> <img src="https://www.gravatar.com/avatar/54f1cca533c3438df8a75544ff239fa8.png?s=80" class="gravatar"> </a> <span class="logo-prompt">Back to Home</span></aside><main> <noscript><style> article .footnotes { display: block; }</style></noscript><article><div class="center"><h1>Solvepnp 5 Methods In Opencv3</h1><time>March 21, 2017</time></div><div class="divider"></div><h4 id="before-begin">Before Begin</h4><p>SolvePnP , Finds an object pose from 3D-2D point correspondences., which is the method that rebuild 3D position from 2D picture.</p><p>We DO NOT Care about the how to use SolvePnP, we try to understand the inner meaning of SolvePnP, and the 5 methods.</p><h4 id="solvepnp-methods-and-paper-table">SolvePnP Methods and Paper table:</h4><table><thead><tr><th style="text-align: center">SolvePnP Methods</th><th style="text-align: center">Reference Paper</th><th style="text-align: center">year</th><th style="text-align: center">cited</th></tr></thead><tbody><tr><td style="text-align: center">SOLVEPNP_ITERATIVE</td><td style="text-align: center">Original based on Levenberg-Marquardt optimization</td><td style="text-align: center"> </td><td style="text-align: center"> </td></tr><tr><td style="text-align: center">SOLVEPNP_EPNP</td><td style="text-align: center">EPnP: Efficient Perspective-n-Point Camera Pose Estimation</td><td style="text-align: center">2008</td><td style="text-align: center">670</td></tr><tr><td style="text-align: center">SOLVEPNP_P3P</td><td style="text-align: center">Complete Solution Classification for the Perspective-Three-Point Problem</td><td style="text-align: center">2003</td><td style="text-align: center">335</td></tr><tr><td style="text-align: center">SOLVEPNP_DLS</td><td style="text-align: center">A Direct Least-Squares (DLS) Method for PnP</td><td style="text-align: center">2011</td><td style="text-align: center">89</td></tr><tr><td style="text-align: center">SOLVEPNP_UPNP</td><td style="text-align: center">Exhaustive Linearization for Robust Camera Pose and Focal Length Estimation</td><td style="text-align: center">2013</td><td style="text-align: center">23</td></tr></tbody></table><p>Methods for solving a PnP problem:</p><ul><li><strong>SOLVEPNP_ITERATIVE</strong> Iterative method is based on Levenberg-Marquardt optimization. In this case the function finds such a pose that minimizes reprojection error, that is the sum of squared distances between the observed projections imagePoints and the projected (using projectPoints ) objectPoints .</li><li><strong>SOLVEPNP_P3P</strong> Method is based on the paper of X.S. Gao, X.-R. Hou, J. Tang, H.-F. Chang “Complete Solution Classification for the Perspective-Three-Point Problem”. In this case the function requires exactly four object and image points.</li><li><strong>SOLVEPNP_EPNP</strong> Method has been introduced by F.Moreno-Noguer, V.Lepetit and P.Fua in the paper “EPnP: Efficient Perspective-n-Point Camera Pose Estimation”.</li><li><strong>SOLVEPNP_DLS</strong> Method is based on the paper of Joel A. Hesch and Stergios I. Roumeliotis. “A Direct Least-Squares (DLS) Method for PnP”.</li><li><strong>SOLVEPNP_UPNP</strong> Method is based on the paper of A.Penate-Sanchez, J.Andrade-Cetto, F.Moreno-Noguer. “Exhaustive Linearization for Robust Camera Pose and Focal Length Estimation”. In this case the function also estimates the parameters \f$f_x\f$ and \f$f_y\f$ assuming that both have the same value. Then the cameraMatrix is updated with the estimated focal length.</li></ul><hr /><h3 id="1-solvepnp_iterative">1. SOLVEPNP_ITERATIVE</h3><p>Accroding to <code class="highlighter-rouge">solvepnp.cpp</code>:</p><div class="highlighter-rouge"><pre class="highlight"><code>else if (flags == SOLVEPNP_ITERATIVE)
{
    CvMat c_objectPoints = opoints, c_imagePoints = ipoints;
    CvMat c_cameraMatrix = cameraMatrix, c_distCoeffs = distCoeffs;
    CvMat c_rvec = rvec, c_tvec = tvec;
    cvFindExtrinsicCameraParams2(&amp;c_objectPoints, &amp;c_imagePoints, &amp;c_cameraMatrix,
                                 c_distCoeffs.rows*c_distCoeffs.cols ? &amp;c_distCoeffs : 0,
                                 &amp;c_rvec, &amp;c_tvec, useExtrinsicGuess );
    result = true;
}
</code></pre></div><p>Which meanings this Method use the function <code class="highlighter-rouge">cvFindExtrinsicCameraParams2</code> in <code class="highlighter-rouge">calibration.cpp</code>.</p><h4 id="about-cvfindextrinsiccameraparams2">About cvFindExtrinsicCameraParams2</h4><p>In this moment, should reference <a href="http://docs.opencv.org/3.1.0/d9/d0c/group__calib3d.html">offical calib3d</a>. In Detailed Desciption, focus on the perspective transformation.</p><p><img src="http://www.opencv.org.cn/opencvdoc/2.3.2/html/_images/math/50a3464c85a412907d91fd8895108ff692eb8d08.png" alt="original-photo" /></p><ul><li>(X, Y, Z) are the coordinates of a 3D point in the world coordinate space</li><li><table><tbody><tr><td>(R</td><td>t) is the Camera’s Rotation and Position, which is what we need to know</td></tr></tbody></table></li><li>fx, fy, cx, cy is the Camera’s intrinsic</li><li>s is Focal length</li><li>u v are the coordinates of the projection point in pixels(picture)</li></ul><p>or can use this table:</p><p><img src="http://docs.opencv.org/2.4/_images/math/f51a5ba02487486308c29bef720f3186d18abac6.png" alt="other-photo" /></p><p>In <code class="highlighter-rouge">cvFindExtrinsicCameraParams2</code>, you can get Camera extrinsic from intrinsic, camera intrinsic matrix and distortion coefficients.</p><p>Camera extrinsic is Camera’s Postion and Rotation, in the other word, if the Camera is static, then can get the Object’s Position and Rotation, but the output is reversed. :)</p><h4 id="how-to-calc-cvfindextrinsiccameraparams2">How to Calc cvFindExtrinsicCameraParams2</h4><p>Back to <code class="highlighter-rouge">cvFindExtrinsicCameraParams2</code>, this function use DLT(Direct Linear Transform) algorithm solve it, and refine extrinsic parameters using Levenberg-Marquardt algorithm.</p><h3 id="2-solvepnp_p3p">2. SOLVEPNP_P3P</h3><p>todo</p><h3 id="3-solvepnp_epnp">3. SOLVEPNP_EPNP</h3><p>reference: <a href="http://www.cnblogs.com/jian-li/p/5689122.html">SolvePnp Algorithm(Chinese Version)</a> and Paper.</p><p>Key Word: SVD(Singular Value Decomposition)</p><p>First, you should understand that every point can be present by four base point in 3D space. In theory, the control points(four base points) can be chosen arbitrarily, However, in practice, found that the stability of the paper’s method is increased by taking the centroid of the reference points as one, and to select the rest in such a way that they form a basis aligned with the principal directions.</p><p>First, look at this basic fomulation:</p><table><tbody><tr><td>![](http://latex.codecogs.com/gif.latex?\inline&amp;space;\omega_i\begin{bmatrix}&amp;space;U_i&amp;space;\&amp;space;V_i&amp;space;\&amp;space;1&amp;space;\end{bmatrix}&amp;space;=&amp;space;[R</td><td>t]&amp;space;\begin{bmatrix}&amp;space;X&amp;space;\&amp;space;Y&amp;space;\&amp;space;Z&amp;space;\&amp;space;1&amp;space;\end{bmatrix}^T)</td></tr></tbody></table><table><tbody><tr><td>in this case, ![](http://latex.codecogs.com/gif.latex?\inline&amp;space;[R</td><td>t]&amp;space;\begin{bmatrix}&amp;space;X&amp;space;\&amp;space;Y&amp;space;\&amp;space;Z&amp;space;\&amp;space;1&amp;space;\end{bmatrix}^T) is matrix multiplication, Present the object point transform from World coordinate to Camera coordinate, meanings the Object position in Camera view, and this can be present by four base points.</td></tr></tbody></table><table><tbody><tr><td>![Fomulation](http://latex.codecogs.com/gif.latex?\inline&amp;space;\sum_{j=1}^4\alpha_{ij}f_ux^c_j&amp;space;=&amp;space;[R</td><td>t]&amp;space;\begin{bmatrix}&amp;space;X&amp;space;\&amp;space;Y&amp;space;\&amp;space;Z&amp;space;\&amp;space;1&amp;space;\end{bmatrix}^T)</td></tr></tbody></table><p>so,</p><table><tbody><tr><td>![](http://latex.codecogs.com/gif.latex?\inline&amp;space;\forall&amp;space;i,&amp;space;\quad&amp;space;\omega_i&amp;space;\left[&amp;space;\begin{array}{c}&amp;space;\mathbf{U_i}&amp;space;\&amp;space;\mathbf{V_i}&amp;space;\&amp;space;1&amp;space;\end{array}&amp;space;\right]&amp;space;=Ap_i^c&amp;space;=A[R</td><td>t]\left[&amp;space;\begin{array}{c}&amp;space;\mathbf{X}&amp;space;\&amp;space;\mathbf{Y}&amp;space;\&amp;space;\mathbf{Z}&amp;space;\&amp;space;1&amp;space;\end{array}&amp;space;\right]^T&amp;space;=A\sum_{j=1}^4\alpha_{ij}c_j^c)</td></tr></tbody></table><p>and, from the last row, you can find</p><p><img src="http://latex.codecogs.com/gif.latex?\omega_i&space;=&space;\sum_{j=1}^4a_{ij}z^c_j" alt="\omega_i = \sum_{j=1}^4a_{ij}z^c_j" /></p><p>so, this matrix can be,</p><p><img src="http://latex.codecogs.com/gif.latex?\sum_{j=1}^4\alpha_{ij}f_ux^c_j&plus;\alpha_{ij}(u_c-u_i)z^c_j=0" alt="\sum_{j=1}^4\alpha_{ij}f_ux^c_j+\alpha_{ij}(u_c-u_i)z^c_j=0 " /></p><p><img src="http://latex.codecogs.com/gif.latex?\sum_{j=1}^4\alpha_{ij}f_v&space;y^c_j&plus;\alpha_{ij}(v_c-v_i)z^c_j=0" alt="\sum_{j=1}^4\alpha_{ij}f_v y^c_j+\alpha_{ij}(v_c-v_i)z^c_j=0" /></p><p>seems like <img src="http://latex.codecogs.com/gif.latex?[M][X]&space;=&space;0" alt="[M][X] = 0" /></p><p>[M] is [2n*12] Matrix, [X] is [12*1] (n meanings the number of Object Points, 12-vector unknow is these four basic points’ position in Camera View.)</p><h3 id="4-solvepnp_dls">4. SOLVEPNP_DLS</h3><p>todo</p><h3 id="5-solvepnp_upnp">5. SOLVEPNP_UPNP</h3><p>todo</p></article><div class="page-navigation"> <a class="home" href="/" title="Back to Homepage">Home</a> <span> &middot; </span> <a class="prev" href="/notes/Install-OpenCV3-QT-in-Debian.html" title="PREV: Install Opencv3 Qt In Debian">&gt;&gt;</a></div></main><div class="footer"> <span class="block">Made with &hearts; using <a href="http://jekyllrb.com/">Jekyll</a> &amp; <a href="https://github.com/heiswayi/the-plain" title="The Plain theme by Heiswayi Nrird">The Plain</a> &middot; &lt;/&gt; on <a href="https://github.com/nimohunter" title="Hosted on GitHub">GitHub</a></span> <span class="block">&copy; 2017 Nimo</span></div></body></html>